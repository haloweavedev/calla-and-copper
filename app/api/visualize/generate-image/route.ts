import { GoogleGenerativeAI } from '@google/generative-ai'
import { NextRequest, NextResponse } from 'next/server'
import { auth } from '@/lib/auth'
import { PrismaClient } from '@prisma/client'

export async function POST(request: NextRequest) {
  const prisma = new PrismaClient()
  const startTime = Date.now()
  let generationRecord: any = null

  try {
    // Get authenticated user
    const session = await auth.api.getSession({
      headers: request.headers,
    })

    if (!session) {
      await prisma.$disconnect()
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const body = await request.json()
    const { roomImageBase64, roomImageMimeType, productImageUrl, productCategory, productName, productId, userContext } = body

    // Validate all required fields are present
    if (!roomImageBase64 || !roomImageMimeType || !productImageUrl || !productCategory || !productName) {
      await prisma.$disconnect()
      return NextResponse.json(
        { error: 'Missing required fields: roomImageBase64, roomImageMimeType, productImageUrl, productCategory, productName' },
        { status: 400 }
      )
    }

    console.log('[API] Generating image with Gemini for product category:', productCategory)
    console.log('[API] User context provided:', !!userContext)

    // Create generation record
    generationRecord = await prisma.imageGeneration.create({
      data: {
        userId: session.user.id,
        generationType: 'single-product',
        prompt: `Add ${productName} (${productCategory}) to room`,
        inputImageUrl: `data:${roomImageMimeType};base64,[BASE64_DATA]`, // Don't store full base64 to avoid huge logs
        productIds: productId ? [String(productId)] : [],
        metadata: {
          productName,
          productCategory,
          productImageUrl,
          userContext: userContext || null,
        },
        status: 'pending',
      },
    })

    console.log('[API] Generation record created:', generationRecord.id)

    const genAI = new GoogleGenerativeAI(process.env.GOOGLE_GENERATIVE_AI_API_KEY!)

    // Add personalization context
    let styleContext = ''
    if (userContext) {
      const { styleProfile, lifestyleTags } = userContext
      const primaryStyle = styleProfile?.styleProfile?.styleHierarchy?.foundation || 'cozy and inviting'
      styleContext = ` in a ${primaryStyle} style`
      
      if (lifestyleTags?.length > 0) {
        styleContext += ` that suits a ${lifestyleTags.join(', ').toLowerCase()} lifestyle`
      }
    }

    // Simple, natural prompt following Gemini's best practices
    let promptText = `Create a new image by combining the room from the first image with the ${productName} from the second image. Add the ${productName} to the room naturally and tastefully${styleContext}.

Keep the room's walls, flooring, lighting, windows, and all architectural details exactly the same as the original room image. You may remove or replace any existing furniture if needed to make space for the new piece. Place it where it looks most natural and functional.

The final image should show the same room with the ${productName} integrated seamlessly.`

    console.log('[API] Sending personalized prompt to Gemini:', promptText)

    // Fetch and convert product image to base64
    const productResponse = await fetch(productImageUrl)
    const productArrayBuffer = await productResponse.arrayBuffer()
    const base64ProductImage = Buffer.from(productArrayBuffer).toString('base64')
    const productMimeType = productResponse.headers.get('content-type') || 'image/jpeg'

    const contentParts = [
      {
        inlineData: {
          mimeType: roomImageMimeType,
          data: roomImageBase64,
        },
      },
      {
        inlineData: {
          mimeType: productMimeType,
          data: base64ProductImage,
        },
      },
      { text: promptText }
    ]

    const model = genAI.getGenerativeModel({ model: 'gemini-2.5-flash-image-preview' })
    const result = await model.generateContent(contentParts)

    console.log('[API] Gemini generation completed, checking for image parts...')

    // Check if result contains image parts
    const response = await result.response
    const parts = response.candidates?.[0]?.content?.parts

    if (!parts || parts.length === 0) {
      throw new Error('No content parts generated by Gemini')
    }

    // Find the first image part
    const imagePart = parts.find((part: any) => part.inlineData)
    
    if (!imagePart || !imagePart.inlineData) {
      throw new Error('No image was generated by Gemini')
    }

    console.log(`[API] Image file received, type: ${imagePart.inlineData.mimeType}`)
    console.log(`[API] Generated image file received successfully`)

    // Get the raw base64 string
    const rawBase64 = imagePart.inlineData.data
    
    // Construct the proper Data URL with prefix
    const dataUrl = `data:${imagePart.inlineData.mimeType || 'image/png'};base64,${rawBase64}`

    console.log('[API] Image generation successful, returning data URL')

    // Update generation record with success
    if (generationRecord) {
      await prisma.imageGeneration.update({
        where: { id: generationRecord.id },
        data: {
          status: 'completed',
          outputImageUrl: dataUrl,
          processingTimeMs: Date.now() - startTime,
        },
      })
    }

    return NextResponse.json({ 
      imageUrl: dataUrl,
      generationId: generationRecord?.id 
    }, { status: 200 })

  } catch (error) {
    console.error('[API] Error in generate-image route:', error)
    
    // Update generation record with error
    if (generationRecord) {
      try {
        await prisma.imageGeneration.update({
          where: { id: generationRecord.id },
          data: {
            status: 'failed',
            errorMessage: error instanceof Error ? error.message : 'Unknown error',
            processingTimeMs: Date.now() - startTime,
          },
        })
      } catch (updateError) {
        console.error('[API] Failed to update generation record:', updateError)
      }
    }

    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  } finally {
    await prisma.$disconnect()
  }
}